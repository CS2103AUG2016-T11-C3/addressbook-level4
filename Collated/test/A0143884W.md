# A0143884W
###### /java/seedu/address/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_editName_successful() throws Exception {
        genericEdit("A1", 1, "new name");
    }

    @Test
    public void execute_editDescription_sucessful() throws Exception {
        genericEdit("A1", 2, "new description");
    }

    @Test
    public void execute_editDate_sucessful() throws Exception {
        genericEdit("A1", 3, "today");
    }
    
    @Test
    public void execute_view_successful() throws Exception {
    	List<Task> taskList = helper.generateDatedTaskList(9);
    	taskList.forEach(temp -> {
    		model.addTask(temp);
    	});
    	
    	assertViewCommand("tmr", 0);
    	assertViewCommand("12-Nov-2018", 1);
    	assertViewCommand("14 Nov 2018", 2);
    	assertViewCommand("16-11-2018", 3);
    }
    
    private void assertViewCommand(String date, int listSize) {
    	CommandResult result = logic.execute("view " + date);
    	assertEquals(logic.getFilteredDatedTaskList().size(), listSize);   
    }

    private void genericEdit(String index, int type, String field) throws Exception, DuplicateTaskException, IllegalValueException {
        // actual to be edited
        Task toBeEdited = helper.floatTaskA();
        toBeEdited.setTags(new UniqueTagList());
        model.addTask(toBeEdited);

        // expected result after edit
        // NOTE: can't simply set description of toBeEdited; need to create new copy,
        // since it will edit the task in model (model's task is simply a reference)
        Task edited = copyTask(toBeEdited);

        switch (type){
        case 1:
            edited.setName(new Name(field));
            break;
        case 2:
            edited.setDescription(new Description(field));
            break;	
        case 3:	
            edited.setDatetime(new Datetime(field));
            break;
        case 4:
            String [] StringArray = field.split(" ");
            Tag [] tagsArray = new Tag [StringArray.length];
            for (int i = 0; i < tagsArray.length; i++){
                tagsArray[i] = new Tag(StringArray[i]);
            }
            edited.setTags(new UniqueTagList(tagsArray));
            break;	
        }

        expectedTB.addTask(edited);

        // execute command and verify result
        assertCommandBehavior(helper.generateEditCommand(index, type, field),
                String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, edited),
                expectedTB, expectedTB.getDatedTaskList(),
                expectedTB.getUndatedTaskList());
    }

    private Task copyTask(Task toBeEdited){
        Task edited = new Task(toBeEdited.getName(), toBeEdited.getDescription(), toBeEdited.getDatetime(),
                toBeEdited.getStatus(), toBeEdited.getTags());
        return edited;
    }

    // TODO: currently, edits that don't include old tags removes all tags 
    // masterlist of tags in TaskBook also need to be changed
    @Test
    public void execute_editDated_successful() throws Exception {

        // initial task in actual model to be edited
        Task original = new Task (new Name("adam"), new Description("111111"),
                new Datetime("11-11-2018 1111"), new Status(State.NONE), 
                new UniqueTagList(new Tag("tag1"), new Tag("tag2")));

        model.addTask(original);

        String [] editInputs = new String [] {
                "edit B1 name changed t/tag1 t/tag2", // edit name
                "edit B1 d/change description too t/tag1 t/tag2", // edit description
                "edit B1 date/12-11-2018 1111 t/tag1 t/tag2", // edit date
                "edit B1 t/tag3 t/tag4", // edit tags
                "edit B1 date/ t/tag3 t/tag4" // edit dated -> undated
        };

        Task editedTasks [] = new Task [] {
                new Task (new Name("name changed"), new Description("111111"), new Datetime("11-11-2018 1111"),
                        new Status(State.NONE), new UniqueTagList(new Tag("tag1"), new Tag("tag2"))),
                new Task (new Name("name changed"), new Description("change description too"), new Datetime("11-11-2018 1111"),
                        new Status(State.NONE), new UniqueTagList(new Tag("tag1"), new Tag("tag2"))),
                new Task (new Name("name changed"), new Description("change description too"), new Datetime("12-11-2018 1111"),
                        new Status(State.NONE), new UniqueTagList(new Tag("tag1"), new Tag("tag2"))),
                new Task (new Name("name changed"), new Description("change description too"), new Datetime("12-11-2018 1111"),
                        new Status(State.NONE), new UniqueTagList(new Tag("tag3"), new Tag("tag4"))),
                new Task (new Name("name changed"), new Description("change description too"), new Datetime(""),
                        new Status(State.NONE), new UniqueTagList(new Tag("tag3"), new Tag("tag4")))
        };

        // state of the TaskBook after each edit
        // for now it's simply editing a single person in the TaskBook
        TaskBook [] expectedTaskBooks = new TaskBook [10];

        for (int i = 0; i < 3; i++){
            expectedTaskBooks[i] = new TaskBook();
            expectedTaskBooks[i].addTask(editedTasks[i]);
            execute_edit(editedTasks[i], expectedTaskBooks[i], editInputs[i]);
        }
    }

    private void execute_edit(Task editedTask, TaskBook expectedTB, String editInput) throws Exception {

        // execute command and verify result
        assertCommandBehavior(editInput,
                String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, editedTask),
                expectedTB, expectedTB.getDatedTasks(),
                expectedTB.getUndatedTaskList());
    }
    
```
