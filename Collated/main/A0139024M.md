# A0139024M
###### \java\seedu\address\logic\commands\RefreshCommand.java
``` java
public class RefreshCommand extends Command {

    public static final String COMMAND_WORD = "refresh";
    public static final String MESSAGE_SUCCESS = "Task Manager has been refreshed with local time!";

    public RefreshCommand (){}

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredDatedTaskList();
        LocalDateTime currentTime = LocalDateTime.now();

        for (ReadOnlyTask target : lastShownList) {
            if(target.getDatetime().getEnd() == null){
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm");
                LocalDateTime dateTime = LocalDateTime.parse(target.getDatetime().toString(), formatter);
                if(dateTime.isBefore(currentTime)){
                    try {
                        model.overdueTask(target);
                    } catch (TaskNotFoundException e) {}				

                }
            }
        }		
        return new CommandResult(String.format(MESSAGE_SUCCESS));
    }

}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public void checkStatus(){
        UniqueTaskList tasks = taskBook.getUniqueDatedTaskList();
        UniqueTaskList floating = taskBook.getUniqueUndatedTaskList();
        LocalDateTime currentTime = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm");       
        checkDatedTaskStatus(tasks, currentTime, formatter);
        checkUndatedTaskStatus(floating);
    }
    
    /*
     * Update the status of all Undated/Floating Tasks in application
     */
    private void checkUndatedTaskStatus(UniqueTaskList floating) {
        for (Task undatedTarget : floating) {
            if (undatedTarget.getStatus().status == Status.State.OVERDUE || undatedTarget.getStatus().status == Status.State.OVERDUE ) {
                try {
                    taskBook.resetFloatingTaskStatus(undatedTarget);
                }catch (TaskNotFoundException e){}
            }
        }
    }
    
    /*
     * Update the status of all Dated Tasks in application
     */
    private void checkDatedTaskStatus(UniqueTaskList tasks, LocalDateTime currentTime, DateTimeFormatter formatter) {
        for (Task target : tasks) {
            assert target.getDatetime().getStart() != null;
            //Deadline
            if (target.getDatetime().getEnd() == null) {
                updateDeadlineStatus(currentTime, formatter, target);
            }
            //Event
            else if (target.getDatetime().getEnd() != null) {
                updateEventStatus(currentTime, formatter, target);                                
            }
        }
    }
    
    /*
     * Updated the status of all Event Tasks in application
     */
    private void updateEventStatus(LocalDateTime currentTime, DateTimeFormatter formatter, Task target) {
        String endDateTime = target.getDatetime().toString().substring(21);
        LocalDateTime dateTime = LocalDateTime.parse(endDateTime,formatter);
        if (dateTime.isBefore(currentTime) && target.getStatus().status != Status.State.DONE) {
            try {
                taskBook.setExpire(target);
            }catch (TaskNotFoundException e) {
                throw new AssertionError("Impossible!");
            }                
        }
        else if (dateTime.isAfter(currentTime) && (target.getStatus().status == Status.State.EXPIRE || target.getStatus().status == Status.State.OVERDUE)) {
            try {
                taskBook.postponeTask(target);
            }catch (TaskNotFoundException e) {
                throw new AssertionError("Impossible!");
            }
        }
    }
    
    /*
     * Updated the status of all Deadline tasks in application
     */
    private void updateDeadlineStatus(LocalDateTime currentTime, DateTimeFormatter formatter, Task target) {
        LocalDateTime dateTime = LocalDateTime.parse(target.getDatetime().toString(), formatter);
        if (dateTime.isBefore(currentTime) && target.getStatus().status != Status.State.DONE) {
            try {
                taskBook.setTaskOverdue(target);
            }catch (TaskNotFoundException e) {
                throw new AssertionError("Impossible!");
            }                
        }
        else if (dateTime.isAfter(currentTime) && (target.getStatus().status == Status.State.OVERDUE || target.getStatus().status == Status.State.EXPIRE)) {
            try {
                taskBook.postponeTask(target);
            }catch (TaskNotFoundException e) {
                throw new AssertionError("Impossible!");
            }
        }
    }
```
###### \java\seedu\address\model\task\UniqueTaskList.java
``` java
    /**
     * Overdues the equivalent task from the list.
     *(Set status to OVERDUE)
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean overdue(ReadOnlyTask target) throws TaskNotFoundException {
        if (!internalList.contains(target)) {
            throw new TaskNotFoundException();
        }
        Task taskFoundAndSetAsOverdue = internalList.get(internalList.indexOf(target));
        return taskFoundAndSetAsOverdue.setAsOverdue();
    }
    
    /**
     * Postpone the equivalent task from the list.
     * (Set status to NONE)
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean postponed(Task target) throws TaskNotFoundException {
        if (!internalList.contains(target)) {
            throw new TaskNotFoundException();
        }
        Task taskFoundAndSetAsPostponed = internalList.get(internalList.indexOf(target));
        return taskFoundAndSetAsPostponed.setAsNorm();       
    }

    /**
     * Expire the equivalent task from the list.
     * (Set status to EXPIRE)
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean expire(Task target) throws TaskNotFoundException {
        if(!internalList.contains(target)){
            throw new TaskNotFoundException();
        }
        Task taskFoundAndSetAsExpired = internalList.get(internalList.indexOf(target));
        return taskFoundAndSetAsExpired.setAsExpire();
    }
```
###### \java\seedu\address\model\TaskBook.java
``` java
    
    /*
     * Set deadline task as overdue
     */
    public boolean setTaskOverdue(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException {
        if (datedTasks.contains(target)) {
            datedTasks.overdue(target);
            return true;
        }
        else {
            throw new UniqueTaskList.TaskNotFoundException();	
        }
    }
    
    /*
     * Reset the status of dated Task to None
     */
    public boolean postponeTask(Task target) throws UniqueTaskList.TaskNotFoundException {
        if (datedTasks.contains(target)) {
            datedTasks.postponed(target);
            return true;
        }
        else {
            throw new UniqueTaskList.TaskNotFoundException();   
        }        
    }
    
    /*
     * Set Event task as expired
     */
    public boolean setExpire(Task target) throws UniqueTaskList.TaskNotFoundException {
        if (datedTasks.contains(target)) {
            datedTasks.expire(target);
            return true;
        }
        else {
            throw new UniqueTaskList.TaskNotFoundException(); 
        }

    }
    /*
     * Clear all unwanted status (Expire/Overdue) status on floating/undated task
     */
    public boolean resetFloatingTaskStatus(Task undatedTarget) throws UniqueTaskList.TaskNotFoundException {
        if (undatedTasks.contains(undatedTarget)) {
            undatedTasks.postponed(undatedTarget);
            return true;
        }
        else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
```
