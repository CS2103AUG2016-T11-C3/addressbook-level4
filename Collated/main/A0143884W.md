# A0143884W
###### /java/seedu/address/commons/events/ui/JumpToListRequestEvent.java
``` java
/**
 * Indicates a request to jump to the list of task
 */
public class JumpToListRequestEvent extends BaseEvent {

	public static int UNDATED_LIST = 1;
	public static int DATED_LIST = 2;
	
    public final int targetIndex;
    public final int listType;
    

    public JumpToListRequestEvent(int targetIndex, int listType) {
        this.targetIndex = targetIndex;
        this.listType = listType;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/address/commons/events/ui/UpdateListCountEvent.java
``` java
/**
 * Indicates a request to update the list count
 */
public class UpdateListCountEvent extends BaseEvent {

	public final Model model; 
	
	public UpdateListCountEvent(Model model){
		this.model = model;
	}
	
	@Override
	public String toString() {
		return this.getClass().getSimpleName();
	}

}
```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to the task book.
 */
public class AddCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task book.\n"
            + "Parameters: TASKNAME d/TASK_DESCRIPTION date/DD-MM-YYYY [24HR] [to 24HR] [t/TAG]...\n" + "Example: "
            + COMMAND_WORD + " Wash Clothes d/Wash with detergent date/27-9-2016 2359 t/!!!";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task book!";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String description, String datetime, Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        this.toAdd = new Task(new Name(name), 
                new Description(description), 
                new Datetime(datetime), 
                new Status(State.NONE),
                new UniqueTagList(tagSet));
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        boolean duplicate = model.addTask(toAdd);
        populateUndo();
        if (duplicate){
        	return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd) + "\n" + MESSAGE_DUPLICATE_TASK);
        } else {
        	return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        }

    }
    
    @Override
    public void populateUndo(){
        assert COMMAND_WORD != null;
        assert toAdd != null;
        model.addUndo(COMMAND_WORD, toAdd);
        model.clearRedo();
    }
}
```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task book.
 */
public class EditCommand extends Command implements Undoable{

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number given in the most recent listing.\n"
            + "Parameters: INDEX\n"
            + "Example: " + COMMAND_WORD + " A1 do that instead date/13-10-16";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";

    private ReadOnlyTask toEdit;
    private Task toAdd;

    private String targetIndex;
    private Name name;
    private Description description;
    private Datetime datetime;
    private UniqueTagList tags;

    public EditCommand(String targetIndex, String name, String description, String datetime, Set<String> tagsList)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagsList) {
            tagSet.add(new Tag(tagName));
        }    

        populateNonNullFields(targetIndex, name, description, datetime, tagSet);
    } 

    @Override
    public CommandResult execute() {
        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> lastDatedTaskList = model.getFilteredDatedTaskList();
        UnmodifiableObservableList<ReadOnlyTask> lastUndatedTaskList = model.getFilteredUndatedTaskList();

        if (!CommandUtil.isValidIndex(targetIndex, lastUndatedTaskList.size(), lastDatedTaskList.size())){
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        toEdit = CommandUtil.getTaskFromCorrectList(targetIndex, lastDatedTaskList, lastUndatedTaskList);
        
        populateEditedTaskFields();
        
        boolean duplicate = false;
        try {
        	model.deleteTask(toEdit);  
            duplicate = model.addTask(toAdd);                
            populateUndo();
        }  catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        }

        if (duplicate){
        	return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, toAdd) + "\n" + AddCommand.MESSAGE_DUPLICATE_TASK);
        } else {
        	return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, toAdd));
        }
    }
    
    /**
     * populates non-null instance variables of EditCommand and validates them 
     * 
     * @param targetIndex
     * @param name
     * @param description
     * @param datetime
     * @param tagSet
     * @throws IllegalValueException
     */   
    private void populateNonNullFields(String targetIndex, String name, String description, String datetime,
            final Set<Tag> tagSet) throws IllegalValueException {
        if (name != null){
            this.name = new Name(name);       
        }
        
        if (description != null){
            this.description = new Description(description);
        }

        if (datetime != null){
            this.datetime = new Datetime(datetime);
        }

        this.tags = new UniqueTagList(tagSet);
        this.targetIndex = targetIndex;
    }  
 
    /**
     * combine edit inputs into task to be added
     */
    private void populateEditedTaskFields() {

        toAdd  = new Task (toEdit.getName(), toEdit.getDescription(), toEdit.getDatetime(), 
                toEdit.getStatus(), toEdit.getTags());

        if (name != null){
            toAdd.setName(name);     
        }
        if (description != null){
            toAdd.setDescription(description);
        }
        if (datetime != null){
            toAdd.setDatetime(datetime);
        }
        if (!tags.isEmpty()){
            toAdd.setTags(tags);
        }
    }

    @Override
    public void populateUndo(){
        assert COMMAND_WORD != null;
        assert toAdd != null;
        assert toEdit != null;
        model.addUndo(COMMAND_WORD, toAdd, toEdit);
        model.clearRedo();
    } 

}
```
###### /java/seedu/address/logic/commands/SelectCommand.java
``` java
/**
 * Selects a task identified using it's last displayed index from the task book.
 */
public class SelectCommand extends Command {

    public final String targetIndex;

    public static final String COMMAND_WORD = "select";
    public static final String COMMAND_ALIAS = "sel";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Selects the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX\n"
            + "Example: " + COMMAND_WORD + " A1";

    public static final String MESSAGE_SELECT_TASK_SUCCESS = "Selected Task: %1$s";

    public SelectCommand(String targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastDatedTaskList = model.getFilteredDatedTaskList();
        UnmodifiableObservableList<ReadOnlyTask> lastUndatedTaskList = model.getFilteredUndatedTaskList();

        if (!CommandUtil.isValidIndex(targetIndex, lastUndatedTaskList.size(), 
                lastDatedTaskList.size())){
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        indicateScrollToTargetIndex();

        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, targetIndex));
    }

    /**
     * post an event to scroll to targetIndex
     */
	private void indicateScrollToTargetIndex() {
		TaskType type = CommandUtil.getTaskType(targetIndex);
        int indexNum = CommandUtil.getIndex(targetIndex);
        
        if (type == TaskType.DATED) {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(indexNum - 1, JumpToListRequestEvent.DATED_LIST));
        } else if (type == TaskType.UNDATED){
            EventsCenter.getInstance().post(new JumpToListRequestEvent(indexNum - 1, JumpToListRequestEvent.UNDATED_LIST));
        } else {
            assert false : "Task type not found";
        }
	}

}
```
###### /java/seedu/address/logic/commands/ViewCommand.java
``` java
/**
 * Populate the list of tasks happening on the selected DATE 
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": View the list of tasks happening on the selected DATE \n"
            + "Parameters: DATE \n"
            + "Example: " + COMMAND_WORD + " today";

    private final Datetime datetime;

    public ViewCommand(String date) throws IllegalValueException {
		this.datetime = new Datetime(date);
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByDate(datetime.getStart());
        return new CommandResult("Viewing tasks for " + datetime.getDateString());
    }
}
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the view task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String arguments) {
    	try {
            return new ViewCommand(arguments);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
	}

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args){
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }	

        try {
            return new AddCommand(
                    matcher.group("name"),
                    matcher.group("description"),
                    matcher.group("date"),
                    getTagsFromArgs(matcher.group("tagArguments"))
                    );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the edit person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args) {

        final Matcher matcher = EDIT_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        try {
            return new EditCommand(
                    (matcher.group("index").toUpperCase()),
                    matcher.group("name"),
                    matcher.group("description"),
                    matcher.group("date"),
                    getTagsFromArgs(matcher.group("tagArguments"))
                    );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public synchronized boolean addTask(Task target) {
        boolean duplicate = taskBook.addTask(target);
        updateFilteredListToShowAll();
        indicateTaskBookChanged();
        scrollToAddedTask(target);
        return duplicate;
    }

    /**
     * after task is added, scroll to it in the UndatedListPanel || DatedListPanel
     * @param target
     */ 
    private void scrollToAddedTask(Task target) {
        int [] result = indexOfAddedTask(target);       
        raise (new JumpToListRequestEvent(result[0], result[1]));
    }

    /**
     * find the task's list and index
     * @param target
     * @return
     */
    private int[] indexOfAddedTask(Task target) {
        int datedTaskIndex = filteredDatedTasks.indexOf(target);
        int undatedTaskIndex = filteredUndatedTasks.indexOf(target);
        int [] result = new int[2];
        // indexOf returns -1 if task not found in the list
        if (datedTaskIndex == -1){
            result[0] = undatedTaskIndex;
            result[1] = JumpToListRequestEvent.UNDATED_LIST;
        } else if (undatedTaskIndex == -1){
            result[0] = datedTaskIndex;
            result[1] = JumpToListRequestEvent.DATED_LIST;
        }
        return result;
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    /**
     * Qualifies if tasks fall on input date
     */
    private class DateQualifier implements Qualifier {
        private Date inputDate;

        DateQualifier(Date date) {
            this.inputDate = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            Datetime taskDate = task.getDatetime();
            Date startDate = taskDate.getStart();
            Date endDate = taskDate.getEnd();

            if (sameDate(startDate)){ // check start date
                return true;
            } else if (endDate != null && sameDate(endDate)){  // check end date only
                return true;
            } else if (endDate != null && inputDate.after(startDate) && inputDate.before(endDate)){ // check between start and end date only
                return true;
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            return "date=" + inputDate.toString();
        }

        // excludes time when checking for equality
        private boolean sameDate(Date other){
            return inputDate.getDate() == other.getDate() && inputDate.getMonth() == other.getMonth() 
                    && inputDate.getYear() == other.getYear();
        }
    }
```
###### /java/seedu/address/model/task/Task.java
``` java
    @Override
    public int compareTo(Task other) {
        return Comparators.NAME.compare(this, other);
    }

    /** 
     * Compares between tasks
     */
    public static class Comparators {

    	/**
    	 * Compares tasks by alphabetical order of NAME
    	 */
        public static Comparator<Task> NAME = new Comparator<Task>() {
            @Override
            public int compare(Task t1, Task t2) {
                return t1.getName().toString().toLowerCase().compareTo(t2.getName().toString().toLowerCase());
            }
        };
        
        /**
         * Compares tasks by chronological order of DATE
         */
        public static Comparator<Task> DATE = new Comparator<Task>() {
            @Override
            public int compare(Task t1, Task t2) {
                Datetime d1 = t1.getDatetime();
                Datetime d2 = t2.getDatetime();

                return d1.getStart().compareTo(d2.getStart());
            }
        };
    }
}
```
