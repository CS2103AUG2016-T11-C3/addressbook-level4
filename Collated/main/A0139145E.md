# A0139145E
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
/**
 * Sets as completed a task identified using it's last displayed index from the task book.
 */
public class DoneCommand extends Command implements Undoable{

    public final String targetIndex;
    public ReadOnlyTask toComplete;

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sets as completed the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX\n"
            + "Example: " + COMMAND_WORD + " A1";

    public static final String MESSAGE_DONE_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_TASK_ALREADY_DONE = "Task is already completed.";

    public DoneCommand(String targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastDatedTaskList = model.getFilteredDatedTaskList();
        UnmodifiableObservableList<ReadOnlyTask> lastUndatedTaskList = model.getFilteredUndatedTaskList();
        
        
        if (!CommandUtil.isValidIndex(targetIndex, lastUndatedTaskList.size(), 
                lastDatedTaskList.size())){
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
        
        TaskType type = CommandUtil.getTaskType(targetIndex);
        int indexNum = CommandUtil.getIndex(targetIndex);
        
        if (type == TaskType.DATED) {
            toComplete = lastDatedTaskList.get(indexNum - 1);
        }
        else if (type == TaskType.UNDATED){
            toComplete = lastUndatedTaskList.get(indexNum - 1);
        }
        else {
            assert false : "Task type not found";
        }

        // Task already completed
        if (toComplete.getStatus().equals(new Status(Status.State.DONE))){
            return new CommandResult(String.format(MESSAGE_TASK_ALREADY_DONE));
        }
        else {
            try {
                model.completeTask(toComplete);
                populateUndo();
            } catch (TaskNotFoundException tnfe) {
                assert false : "The target task cannot be found";
            }
            return new CommandResult(String.format(MESSAGE_DONE_TASK_SUCCESS, toComplete));
            
        }

    }

    @Override
    public void populateUndo(){
        assert COMMAND_WORD != null;
        assert toComplete != null;
        model.addUndo(COMMAND_WORD, toComplete);
    } 
    
}
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_ALIAS = "ls";

    public static final String LIST_KEYWORD_ALL = "all";
    public static final String LIST_KEYWORD_OD = "od";
    public static final String LIST_KEYWORD_DONE = "done";
    public static final String LIST_KEYWORDS = LIST_KEYWORD_ALL + "/" + LIST_KEYWORD_OD + "/" + LIST_KEYWORD_DONE;
    public static Set<String> keywordsList = new HashSet<>(Arrays.asList(LIST_KEYWORDS.split("/")));
    
    
    public static final String MESSAGE_LIST_USAGE = COMMAND_WORD + ": Lists the tasks in the address book.\n"
            + "Parameters: list " + LIST_KEYWORDS + "\n"
            + "Example: " + COMMAND_WORD
            + " done";

    public static final String MESSAGE_SUCCESS = "Listed %1$s tasks";

    private final String keyword;

    public ListCommand(String key) throws IllegalValueException{
        
        if (keywordsList.contains(key)) {
            this.keyword = key;
        }
        else {
            throw new IllegalValueException(MESSAGE_LIST_USAGE);
        }
    }

    @Override
    public CommandResult execute() {
        String taskStatus;

        switch (keyword) {
        case LIST_KEYWORD_ALL:
            taskStatus = "all";
            model.updateFilteredListToShowAll();
            break;

        case LIST_KEYWORD_DONE:
            taskStatus = "completed";
            model.updateFilteredTaskListByStatus("DONE");
            break;

        case LIST_KEYWORD_OD:
            taskStatus = "overdue and expired";
            model.updateFilteredTaskListByStatus("OVERDUE", "EXPIRE");
            break;

        default:
            taskStatus = "";
            assert false : "Missing case in switch statement";
            break;
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskStatus));
    }

}
```
###### \java\seedu\address\logic\commands\Undoable.java
``` java
/**
 * Commands that implement Undoable have actions that can be undo-ed
 */
public interface Undoable {
    
    /** Populates undo with the appropriate data required */
    void populateUndo();
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Lists all persons in the address book to the user.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes the last reversible action from Task Book in this session\n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Action \"%1$s\" has been reverted";

    public static final String MESSAGE_UNDO_NOT_POSSIBLE = "There are no actions available for undo";

    public UndoCommand() {}

    @Override
    public CommandResult execute() {
        assert model != null;
        UndoTask toUndo = model.undoTask();

        //No undoable action found.
        if (toUndo == null) { 
            return new CommandResult(MESSAGE_UNDO_NOT_POSSIBLE);
        }

        try {
            switch (toUndo.getCommand()){

            case AddCommand.COMMAND_WORD:
                model.deleteTask(toUndo.getPostData());
                break;

            case DeleteCommand.COMMAND_WORD:
                model.addTask(toUndo.getPostData());
                break;

            case EditCommand.COMMAND_WORD:
                model.addTask(toUndo.getPreData());
                model.deleteTask(toUndo.getPostData());               
                break;

            case DoneCommand.COMMAND_WORD:
                model.uncompleteTask(toUndo.getPostData());               
                break;

            }
            return new CommandResult(String.format(MESSAGE_SUCCESS, toUndo.getCommand()));
        }
        catch (UniqueTaskList.TaskNotFoundException tnfe){
            assert false : "Task not found";
            return new CommandResult(MESSAGE_UNDO_NOT_POSSIBLE);
        }
        
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredTaskListByStatus("NONE", "OVERDUE", "EXPIRE");
        //filteredDatedTasks.setPredicate(null);
        //filteredUndatedTasks.setPredicate(null);
    }
```
###### \java\seedu\address\model\task\Status.java
``` java
/**
 * Represents a task's status in the to-do-list.
 * Guarantees: immutable
 */
public class Status {

    public static enum State {
        DONE, OVERDUE, NONE, EXPIRE
    }

    public State status;

    public Status(State status) {
        assert status != null;
        this.status = status;
    }
    
    public Status(String statusStr) {
        assert statusStr != null;
        
        this.status = getStatusFromString(statusStr);
    }

    /**
     * Guarantees valid input
     * @param statusStr
     * @return respective enum State
     */
    private State getStatusFromString(String statusStr) {
        
        switch (statusStr) {
        case "DONE":
            return State.DONE;
            
        case "NONE":
            return State.NONE;
            
        case "OVERDUE":
            return State.OVERDUE;
        
        case "EXPIRE":
            return State.EXPIRE;
         
        default:
            return null; //not possible
        }
    }

    @Override
    public String toString() {
        String toReturn;
        
        switch (status) {
        case DONE:
            toReturn = "DONE";
            break;
            
        case NONE:
            toReturn = "NONE";
            break;
            
        case OVERDUE:
            toReturn = "OVERDUE";
            break;
            
        case EXPIRE:
            toReturn = "EXPIRE";
            break;
        
        default:
            toReturn = ""; //Not possible
            break;
        }
        
        return toReturn;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                && this.status.equals(((Status) other).status)); // state check
    }

    @Override
    public int hashCode() {
        return status.hashCode();
    }

}
```
###### \java\seedu\address\model\undo\UndoList.java
``` java
/*
 * Implements a circular linked list to store the UndoTasks (up to 3 actions)
 * using Last-In-First-Out (LIFO)
 */
public class UndoList {

    public static int MAX_UNDO_SIZE = 10;
    public UndoNode head;
    public UndoNode tail;
    private int size;

    public UndoList(){
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    /*
     * Adds a Undo action to the front of the list.
     */
    public void addToFront(String cmd, ReadOnlyTask postData, ReadOnlyTask preData){
        if (size == 0){ //currently empty
            head = new UndoNode(cmd, postData, preData, head, tail);
            tail = head;
            size++;
        }
        else if (size < MAX_UNDO_SIZE){
            tail.setNext(new UndoNode(cmd, postData, preData, head, tail));
            tail = tail.getNext();
            size++;
        }
        else if (size == MAX_UNDO_SIZE){
            head = head.getNext();
            tail.setNext(new UndoNode(cmd, postData, preData, head, tail));
            tail = tail.getNext();
        }
    }

    /**
     * Removes a Undo action to the front of the list.
     * @return UndoTask, or null if no actions to undo
     * 
     **/
    public UndoTask removeFromFront(){
        if (size == 0) {
            return null;
        }
        UndoNode toRm = tail;
        if (size == 1){
            head = null;
            tail = null;
            size--;
            return toRm.getUndoData();
        }
        else {
            tail = tail.getPrev();
            tail.setNext(head);
            size--;
            return toRm.getUndoData();
        }
    }

    @Override
    public String toString(){
        StringBuffer value = new StringBuffer();
        UndoNode temp = tail;
        if (head == null){
            value.append("\n");
        }
        else {
            while (temp != head){
                value.append("--> ").append(temp.getUndoData().toString()).append("\n");
                temp = temp.getPrev();
            }
            value.append("--> ").append(temp.getUndoData().toString()).append("\n");
        }
        return value.toString();
    }

    /*
     * List Node class for the UndoList circular linked list
     */
    class UndoNode {

        public UndoTask data;
        public UndoNode next, prev;

        /*
         * Initialises a UndoNode
         * cmd. postData cannot be null
         */
        public UndoNode(String cmd, ReadOnlyTask postData, ReadOnlyTask preData, UndoNode next, UndoNode prev){
            this.data = new UndoTask(cmd, postData, preData);
            this.next = next;
            this.prev = prev;
        }

        UndoNode getNext(){
            return this.next;
        }

        UndoNode getPrev(){
            return this.prev;
        }

        UndoTask getUndoData(){
            return this.data;
        }

        void setNext(UndoNode next){
            this.next = next;
        }

        void setPrev(UndoNode prev){
            this.prev = prev;
        }
    }
}
```
###### \java\seedu\address\model\undo\UndoTask.java
``` java
/**
 * Represents the data for Undo as a String command and Tasks postData and preData
 * Only for EditCommand, preData will not be null. 
 */
public class UndoTask {
    
    public String command;
    public Task postData;
    public Task preData;
    
    /**
     * Initializes a UndoTask with the given variables
     * command, postData should not be null
     */
    public UndoTask(String command, ReadOnlyTask initData, ReadOnlyTask finalData){
        this.command = command;
        this.postData = new Task(initData);
        if (finalData == null) {
            this.preData = null;
        }
        else {
            this.preData = new Task(finalData);
        }
    }
    
    /*
     * Returns the command stored
     */
    public String getCommand(){
        return command;
    }
    
    /*
     * Returns the initial Task stored
     */
    public Task getPostData(){
        return postData;
    }
    
    /*
     * Returns the final Task stored
     * Not null only when stored command is Edit 
     */
    public Task getPreData(){
        return preData;
    }
    
    @Override
    public String toString(){
        StringBuffer value = new StringBuffer();
        value.append(command).append(":").append(postData);
        if (preData != null){
            value.append(" to ").append(preData);
        }
        return value.toString();
    }
    
}
```
